---
title: Kafka
layout: post
tag: [WIL, Kafka]
toc: true
---

실전 카프카 개발부터 운영을 읽고 제 나름대로 정리한 글 입니다.

## 등장 배경

회사 규모가 커지고 사업이 다각화되면서 데이터에 대한 요구사항이 증가함
-> 데이터의 변화가 스트림으로 컨슈머 측에 전달되는 Event Driven System 으로서의 전환이 필요
데이터를 소비하는 컨슈머들이 자신의 요구사항에 따라 데이터를 처리하거나 구독할 수 있게 됨.

Event Driven Sytsem에서 가장 중요한 것
- 여러 네트워크를 이용하는 환경에서 모든 데이터 변경에 대한 올바른 전달의 보장
- 동일한 데이터를 동시에 수정하면서 순서를 보장
- 다양한 클라이언트들의 요구사항을 효율적으로 지원
- 빠른 전송 또는 대량 전송을 위한 클라이언트를 지원


동기 방식의 Event Driven System에서는 한계가 있다.
비동기 방식의 스트리밍 플랫폼인 Kafka 등장

## Kafka 특징

1. 높은 처리량과 낮은 지연시간
![image](https://github.com/hobit22/hobit22.github.io/assets/40729223/cd89d756-9d7f-4703-8c6f-abad28f57f24)
[Benchmarking Apache Pulsar, Kafka, and RabbitMQ](https://www.confluent.io/blog/kafka-fastest-messaging-system/)

2. 높은 확장성

3. 고가용성

4. 내구성

5. 개발 편의성

6. 운영 및 관리 편의성


## Kafka의 기초

> 주키퍼 : 
카프카 : 
브로커 : 
프로듀서 : 
컨슈머 : 
토픽 : 
파티션 : 
세그먼트 : 
메시지 :

#### 리플리케이션
각 메시지들을 여러 개로 복제해서 카프카 클러스터 내 브로커들에게 분산시키는 동작을 의미.
리플리케이션 동작 덕분에 하나의 브로커가 종료되더라도 안정성을 유지 할 수 있음.



|환경|팩터 수|
|------|---|
|테스트, 개발 환경|1|
|운영 환경(로그성 메시지로서 약간의 유실 허용)|2|
|운영 환경(유실 허용하지 않음)|3|

리플리케이션 수가 많아지면 항상 좋은가?

#### 파티션
하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해 토픽 하나를 여러개로 나눠 병렬처리가 가능하게 만든 것.
파티션 수만큼 컨슈머를 연결 할 수 있음.

파티션 수는 몇 개가 적당한가?


#### 세그먼트
프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장된다.
각 메시지들은 세그먼트라는 로그 파일의 형태로 브로커의 로컬디스크에 저장된다.


## Kafka의 핵심 개념

카프카는 어떻게 높은 처리량과 안정성을 지니게 되었을까?

#### 분산 시스템
카프카는 분산시스템을 사용중이다. 분산시스템이란 하나의 서버 또는 노드 등에 장애가 발생할 때 다른 서버 또는 노드가 대신 처리하여 장애 대응에 탁월하다. 부하가 높을 경우에는 확장이 용이하다.
카프카에서 최초 클러스터의 리소스가 한계치에 도달했을 때, 브로커를 추가하는 방식으로 확장이 가능하다.

#### 페이지 캐시

#### 배치 전송 처리

#### 압축 전송
#### 토픽, 파티션, 오프셋
#### 고가용성 보장
#### 주키퍼의 의존성

## 프로듀서
#### 기본 동작
#### 주요 옵션
#### 예제

## 컨슈머
#### 기본 동작
#### 주요 옵션
#### 예제
#### 컨슈머 그룹

